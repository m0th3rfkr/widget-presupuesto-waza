<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador Excel + MD desde Building Blocks</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .upload-section {
            border: 2px dashed #ddd;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        .config-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        textarea {
            height: 100px;
            resize: vertical;
        }
        button {
            background-color: #007bff;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        .success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 15px;
            border-radius: 4px;
            margin: 15px 0;
        }
        .preview {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
        .preview pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Generador Excel + MD desde Building Blocks JSON</h1>
        <p>Genera autom√°ticamente un Excel estructurado y un documento Markdown desde tu JSON de building blocks</p>
        
        <!-- Secci√≥n de carga -->
        <div class="upload-section">
            <h3>Cargar JSON Building Blocks</h3>
            <div class="form-group">
                <label for="json-file-001">JSON Building Blocks v2.0:</label>
                <input type="file" id="json-file-001" accept=".json" />
            </div>
            <div class="form-group">
                <label for="template-file-002">Template Excel (opcional):</label>
                <input type="file" id="template-file-002" accept=".xlsx,.xls" />
            </div>
        </div>
        
        <!-- Configuraci√≥n del proyecto -->
        <div class="config-section">
            <div>
                <div class="form-group">
                    <label for="nombre-proyecto-003">Nombre del Proyecto:</label>
                    <input type="text" id="nombre-proyecto-003" value="Plataforma Ejemplo" />
                </div>
                
                <div class="form-group">
                    <label for="tarifa-base-004">Tarifa Base por Hora (MXN):</label>
                    <input type="number" id="tarifa-base-004" value="500" min="100" />
                </div>
                
                <div class="form-group">
                    <label for="tarifa-ia-005">Tarifa IA por Hora (MXN):</label>
                    <input type="number" id="tarifa-ia-005" value="300" min="50" />
                </div>
                
                <div class="form-group">
                    <label for="markup-006">Markup Cliente (%):</label>
                    <input type="number" id="markup-006" value="40" min="0" max="200" />
                </div>
                
                <div class="form-group">
                    <label for="eficiencia-ia-007">Eficiencia IA (% reducci√≥n):</label>
                    <input type="number" id="eficiencia-ia-007" value="35" min="0" max="80" />
                </div>
                
                <div class="form-group">
                    <label for="categorias-filtro-008">Categor√≠as a incluir (separadas por coma):</label>
                    <textarea id="categorias-filtro-008" placeholder="Dejar vac√≠o para incluir todas las categor√≠as..."></textarea>
                </div>
            </div>
            
            <div>
                <div class="form-group">
                    <label for="factor-pm-009">Factor PM (%):</label>
                    <input type="number" id="factor-pm-009" value="18" min="0" max="50" />
                </div>
                
                <div class="form-group">
                    <label for="factor-testing-010">Factor Testing (%):</label>
                    <input type="number" id="factor-testing-010" value="12" min="0" max="30" />
                </div>
                
                <div class="form-group">
                    <label for="factor-contingencia-011">Factor Contingencia (%):</label>
                    <input type="number" id="factor-contingencia-011" value="20" min="0" max="50" />
                </div>
            </div>
        </div>
        
        <div style="text-align: center;">
            <button onclick="generarArchivos()">üìä Generar Excel + MD</button>
            <button onclick="generarArchivosConN8N()">ü§ñ Generar con AI (n8n)</button>
            <button onclick="generarGoogleSheets()">üìã Generar Google Sheets</button>
            <button onclick="previsualizarMD()">üëÅÔ∏è Preview MD</button>
        </div>
        
        <!-- Preview del Markdown -->
        <div id="preview-container-012" class="preview" style="display: none;">
            <h4>Preview del Markdown:</h4>
            <pre id="preview-content-013"></pre>
        </div>
    </div>

    <script>
        // Configuraci√≥n OAuth Google
        const CLIENT_ID = '64644619494-tous9hjfmhdpmcfnj18b067tnj3ve9f9.apps.googleusercontent.com';
        const API_KEY = 'AIzaSyA5WkzYdrn2v24fgB1rln5qnbhs7iivFNs';
        const SCOPES = 'https://www.googleapis.com/auth/drive https://www.googleapis.com/auth/spreadsheets';

        let tokenClient;
        let accessToken = null;
        let isGoogleApiLoaded = false;

        let buildingBlocksData = null;
        let templateData = null;
        
        // Event listeners para cargar archivos
        document.getElementById('json-file-001').addEventListener('change', (e) => {
            if (e.target.files[0]) {
                cargarJSON(e.target.files[0]);
            }
        });
        
        document.getElementById('template-file-002').addEventListener('change', (e) => {
            if (e.target.files[0]) {
                cargarTemplate(e.target.files[0]);
            }
        });
        
        // Transformar formato nuevo a formato esperado por el cotizador
        function transformNewFormatToOld(newData) {
            const componentes = [];
            const tarifaBase = 500; // Default tarifa base

            // Validar datos de entrada
            if (!newData || !newData.categories) {
                console.error('‚ùå Datos inv√°lidos para transformaci√≥n');
                return { componentes: [], categories: [] };
            }

            // Mapear categor√≠as a tipos esperados
            const categoryMapping = {
                'arquitectura_tecnica': 'devops',
                'requisitos_funcionales': 'features',
                'requisitos_no_funcionales': 'performance'
            };

            Object.entries(newData.categories).forEach(([categoryKey, category]) => {
                // Validar que category y building_blocks existan
                if (!category || !category.building_blocks) {
                    console.warn(`‚ö†Ô∏è Categor√≠a ${categoryKey} no tiene building_blocks`);
                    return;
                }

                Object.entries(category.building_blocks).forEach(([blockKey, block]) => {
                    // Validar datos del bloque
                    if (!block || !block.name) {
                        console.warn(`‚ö†Ô∏è Bloque ${blockKey} no tiene datos v√°lidos`);
                        return;
                    }

                    const categoria = categoryMapping[categoryKey] || 'features';
                    const complejidad = 'intermedio'; // Default complexity

                    const horas = (block.hours && block.hours[complejidad]) ? block.hours[complejidad] : 40;
                    const costoCliente = horas * tarifaBase;

                    componentes.push({
                        nombre: block.name || `Componente ${blockKey}`,
                        descripcion: block.description || 'Sin descripci√≥n',
                        categoria: categoria,
                        complejidad: complejidad,
                        horas: horas,
                        horasIA: Math.round(horas * 0.7), // 70% IA
                        horasHumanas: Math.round(horas * 0.3), // 30% humanos
                        costoCliente: costoCliente,
                        requirements: block.requirements || [],
                        buildingBlocks: [blockKey]
                    });
                });
            });

            return {
                metadata: newData.metadata,
                componentes: componentes,
                categories: Object.keys(newData.categories).map(key => ({
                    id: key,
                    name: newData.categories[key].name,
                    description: newData.categories[key].description
                }))
            };
        }

        function cargarJSON(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);

                    // Detectar formato y transformar si es necesario
                    if (data.categories && data.metadata) {
                        // Nuevo formato - transformar a formato esperado
                        try {
                            buildingBlocksData = transformNewFormatToOld(data);
                            mostrarMensaje('JSON nuevo formato transformado correctamente', 'success');
                        } catch (transformError) {
                            console.error('‚ùå Error en transformaci√≥n:', transformError);
                            throw new Error('Error transformando el formato JSON: ' + transformError.message);
                        }
                    } else if (data.componentes) {
                        // Formato antiguo
                        buildingBlocksData = data;
                        mostrarMensaje('JSON cargado correctamente', 'success');
                    } else {
                        throw new Error('El JSON no tiene la estructura esperada');
                    }
                } catch (error) {
                    mostrarMensaje('Error al cargar JSON: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }
        
        function cargarTemplate(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const workbook = XLSX.read(e.target.result, { type: 'array' });
                    templateData = workbook;
                    mostrarMensaje('Template Excel cargado correctamente', 'success');
                } catch (error) {
                    mostrarMensaje('Error al cargar template: ' + error.message, 'error');
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function generarArchivos() {
            if (!buildingBlocksData) {
                mostrarMensaje('Primero carga el archivo JSON', 'error');
                return;
            }
            
            try {
                const config = obtenerConfiguracion();
                const datosEstructurados = procesarBuildingBlocks(buildingBlocksData, config);
                
                // Generar Excel nuevo (completo)
                generarExcel(datosEstructurados, config);
                
                // Llenar template si existe
                if (templateData) {
                    llenarTemplate(datosEstructurados, config);
                }
                
                // Generar Markdown
                generarMarkdown(datosEstructurados, config);
                
                mostrarMensaje('Archivos generados correctamente', 'success');
            } catch (error) {
                mostrarMensaje('Error al generar archivos: ' + error.message, 'error');
            }
        }
        
        function obtenerConfiguracion() {
            const categoriasFiltroText = document.getElementById('categorias-filtro-008').value.trim();
            const categoriasFiltro = categoriasFiltroText ? 
                categoriasFiltroText.split(',').map(c => c.trim()) : null;
            
            return {
                nombreProyecto: document.getElementById('nombre-proyecto-003').value,
                tarifaBase: parseFloat(document.getElementById('tarifa-base-004').value),
                tarifaIA: parseFloat(document.getElementById('tarifa-ia-005').value),
                markup: parseFloat(document.getElementById('markup-006').value),
                eficienciaIA: parseFloat(document.getElementById('eficiencia-ia-007').value),
                categoriasFiltro: categoriasFiltro,
                factorPM: parseFloat(document.getElementById('factor-pm-009').value),
                factorTesting: parseFloat(document.getElementById('factor-testing-010').value),
                factorContingencia: parseFloat(document.getElementById('factor-contingencia-011').value)
            };
        }
        
        // Calcular resumen para formato transformado
        function calculateResumen(componentes, config) {
            const resumen = {
                horasTotal: 0,
                horasIA: 0,
                horasHumanas: 0,
                costoTotal: 0,
                costoIA: 0,
                costoHumanos: 0,
                costoCliente: 0,
                componentes: componentes.length
            };

            componentes.forEach(comp => {
                resumen.horasTotal += comp.horas || 0;
                resumen.horasIA += comp.horasIA || 0;
                resumen.horasHumanas += comp.horasHumanas || 0;
                resumen.costoCliente += comp.costoCliente || 0;
            });

            // Aplicar markup
            resumen.costoClienteFinal = Math.round(resumen.costoCliente * (1 + config.markup / 100));

            return resumen;
        }

        function procesarBuildingBlocks(data, config) {
            const componentes = [];
            const categorias = {};
            let idCounter = 1;

            // Detectar si ya est√° transformado (tiene data.componentes)
            if (data.componentes) {
                // Formato ya transformado - usar directamente
                return {
                    componentes: data.componentes,
                    categorias: {},
                    resumen: calculateResumen(data.componentes, config)
                };
            }

            // Formato original - procesar como antes
            for (const [categoriaId, categoria] of Object.entries(data.categories || {})) {
                // Filtrar categor√≠as si se especific√≥
                if (config.categoriasFiltro && 
                    !config.categoriasFiltro.some(filtro => 
                        categoria.name.toLowerCase().includes(filtro.toLowerCase()) ||
                        categoriaId.toLowerCase().includes(filtro.toLowerCase())
                    )) {
                    continue;
                }
                
                if (!categorias[categoria.name]) {
                    categorias[categoria.name] = {
                        horas: { facil: 0, intermedio: 0, complejo: 0 },
                        horasIA: { facil: 0, intermedio: 0, complejo: 0 },
                        costosHumanos: { facil: 0, intermedio: 0, complejo: 0 },
                        costosIA: { facil: 0, intermedio: 0, complejo: 0 },
                        costosCliente: { facil: 0, intermedio: 0, complejo: 0 },
                        items: 0
                    };
                }
                
                for (const [blockId, block] of Object.entries(categoria.building_blocks)) {
                    const horasFacil = block.hours.facil;
                    const horasIntermedio = block.hours.intermedio;
                    const horasComplejo = block.hours.complejo;
                    
                    // Calcular horas con eficiencia IA
                    const factorEficiencia = (100 - config.eficienciaIA) / 100;
                    const horasIAFacil = Math.round(horasFacil * factorEficiencia);
                    const horasIAIntermedio = Math.round(horasIntermedio * factorEficiencia);
                    const horasIAComplejo = Math.round(horasComplejo * factorEficiencia);
                    
                    // Costos humanos
                    const costoHumanoFacil = horasFacil * config.tarifaBase;
                    const costoHumanoIntermedio = horasIntermedio * config.tarifaBase;
                    const costoHumanoComplejo = horasComplejo * config.tarifaBase;
                    
                    // Costos con IA
                    const costoIAFacil = horasIAFacil * config.tarifaIA;
                    const costoIAIntermedio = horasIAIntermedio * config.tarifaIA;
                    const costoIAComplejo = horasIAComplejo * config.tarifaIA;
                    
                    // Costos para cliente (con markup)
                    const factorMarkup = (100 + config.markup) / 100;
                    const costoClienteFacil = costoIAFacil * factorMarkup;
                    const costoClienteIntermedio = costoIAIntermedio * factorMarkup;
                    const costoClienteComplejo = costoIAComplejo * factorMarkup;
                    
                    componentes.push({
                        id: idCounter++,
                        categoria: categoria.name,
                        componente: block.name,
                        buildingBlocks: blockId,
                        // Horas originales
                        horasFacil: horasFacil,
                        horasIntermedio: horasIntermedio,
                        horasComplejo: horasComplejo,
                        // Horas con IA
                        horasIAFacil: horasIAFacil,
                        horasIAIntermedio: horasIAIntermedio,
                        horasIAComplejo: horasIAComplejo,
                        // Costos humanos
                        costoHumanoFacil: costoHumanoFacil,
                        costoHumanoIntermedio: costoHumanoIntermedio,
                        costoHumanoComplejo: costoHumanoComplejo,
                        // Costos IA
                        costoIAFacil: costoIAFacil,
                        costoIAIntermedio: costoIAIntermedio,
                        costoIAComplejo: costoIAComplejo,
                        // Costos cliente
                        costoClienteFacil: costoClienteFacil,
                        costoClienteIntermedio: costoClienteIntermedio,
                        costoClienteComplejo: costoClienteComplejo,
                        functionPoints: block.function_points || { facil: 0, intermedio: 0, complejo: 0 }
                    });
                    
                    // Agregar a totales por categor√≠a
                    categorias[categoria.name].horas.facil += horasFacil;
                    categorias[categoria.name].horas.intermedio += horasIntermedio;
                    categorias[categoria.name].horas.complejo += horasComplejo;
                    categorias[categoria.name].horasIA.facil += horasIAFacil;
                    categorias[categoria.name].horasIA.intermedio += horasIAIntermedio;
                    categorias[categoria.name].horasIA.complejo += horasIAComplejo;
                    categorias[categoria.name].costosHumanos.facil += costoHumanoFacil;
                    categorias[categoria.name].costosHumanos.intermedio += costoHumanoIntermedio;
                    categorias[categoria.name].costosHumanos.complejo += costoHumanoComplejo;
                    categorias[categoria.name].costosIA.facil += costoIAFacil;
                    categorias[categoria.name].costosIA.intermedio += costoIAIntermedio;
                    categorias[categoria.name].costosIA.complejo += costoIAComplejo;
                    categorias[categoria.name].costosCliente.facil += costoClienteFacil;
                    categorias[categoria.name].costosCliente.intermedio += costoClienteIntermedio;
                    categorias[categoria.name].costosCliente.complejo += costoClienteComplejo;
                    categorias[categoria.name].items += 1;
                }
            }
            
            return { componentes, categorias };
        }
        
        function crearContenidoMarkdown(datos, config) {
            let markdown = `# Estructura Excel - Cotizaci√≥n ${config.nombreProyecto}\n\n`;
            markdown += `*Generado con IA - Eficiencia ${config.eficienciaIA}% - Markup ${config.markup}%*\n\n`;
            
            // Hoja 1: Cotizaci√≥n Principal
            markdown += `## Hoja 1: "Cotizaci√≥n_Principal"\n\n`;
            markdown += `| ID | Categor√≠a | Componente | Building Blocks | Horas_IA_B√°sico | Horas_IA_Est√°ndar | Horas_IA_Enterprise | Costo_Cliente_B√°sico | Costo_Cliente_Est√°ndar | Costo_Cliente_Enterprise |\n`;
            markdown += `|----|-----------|------------|-----------------|-----------------|-------------------|---------------------|---------------------|----------------------|------------------------|\n`;
            
            datos.componentes.forEach(comp => {
                markdown += `| ${comp.id} | ${comp.categoria} | ${comp.componente} | ${comp.buildingBlocks} | ${comp.horasIAFacil} | ${comp.horasIAIntermedio} | ${comp.horasIAComplejo} | ${Math.round(comp.costoClienteFacil)} | ${Math.round(comp.costoClienteIntermedio)} | ${Math.round(comp.costoClienteComplejo)} |\n`;
            });
            
            // Hoja 2: Comparativa de Eficiencia
            markdown += `\n## Hoja 2: "Comparativa_Costos"\n\n`;
            markdown += `| Categor√≠a | Nivel | Horas_Humanos | Horas_IA | Costo_Humanos | Costo_IA | Costo_Cliente | Ahorro_Horas | Ahorro_% |\n`;
            markdown += `|-----------|-------|---------------|----------|---------------|----------|---------------|--------------|----------|\n`;
            
            for (const [nombreCat, datosCategoria] of Object.entries(datos.categorias)) {
                ['B√°sico', 'Est√°ndar', 'Enterprise'].forEach((nivel, idx) => {
                    const nivelKey = ['facil', 'intermedio', 'complejo'][idx];
                    const horasHumanos = datosCategoria.horas[nivelKey];
                    const horasIA = datosCategoria.horasIA[nivelKey];
                    const costoHumanos = datosCategoria.costosHumanos[nivelKey];
                    const costoIA = datosCategoria.costosIA[nivelKey];
                    const costoCliente = datosCategoria.costosCliente[nivelKey];
                    const ahorroHoras = horasHumanos - horasIA;
                    const ahorroPorcentaje = horasHumanos > 0 ? ((ahorroHoras / horasHumanos) * 100).toFixed(1) : 0;
                    
                    markdown += `| ${nombreCat} | ${nivel} | ${horasHumanos} | ${horasIA} | ${Math.round(costoHumanos)} | ${Math.round(costoIA)} | ${Math.round(costoCliente)} | ${ahorroHoras} | ${ahorroPorcentaje}% |\n`;
                });
            }
            
            // Hoja 3: Totales por Categor√≠a
            markdown += `\n## Hoja 3: "Totales_por_Categoria"\n\n`;
            markdown += `| Categor√≠a | Items | Horas_IA_B√°sico | Horas_IA_Est√°ndar | Horas_IA_Enterprise | Costo_Cliente_B√°sico | Costo_Cliente_Est√°ndar | Costo_Cliente_Enterprise |\n`;
            markdown += `|-----------|-------|-----------------|-------------------|---------------------|---------------------|----------------------|------------------------|\n`;
            
            let totalHorasIA = { facil: 0, intermedio: 0, complejo: 0 };
            let totalCostosCliente = { facil: 0, intermedio: 0, complejo: 0 };
            
            for (const [nombreCat, datosCategoria] of Object.entries(datos.categorias)) {
                markdown += `| ${nombreCat} | ${datosCategoria.items} | ${datosCategoria.horasIA.facil} | ${datosCategoria.horasIA.intermedio} | ${datosCategoria.horasIA.complejo} | ${Math.round(datosCategoria.costosCliente.facil)} | ${Math.round(datosCategoria.costosCliente.intermedio)} | ${Math.round(datosCategoria.costosCliente.complejo)} |\n`;
                
                totalHorasIA.facil += datosCategoria.horasIA.facil;
                totalHorasIA.intermedio += datosCategoria.horasIA.intermedio;
                totalHorasIA.complejo += datosCategoria.horasIA.complejo;
                totalCostosCliente.facil += datosCategoria.costosCliente.facil;
                totalCostosCliente.intermedio += datosCategoria.costosCliente.intermedio;
                totalCostosCliente.complejo += datosCategoria.costosCliente.complejo;
            }
            
            markdown += `| **TOTAL GENERAL** | **${datos.componentes.length}** | **${totalHorasIA.facil}** | **${totalHorasIA.intermedio}** | **${totalHorasIA.complejo}** | **${Math.round(totalCostosCliente.facil)}** | **${Math.round(totalCostosCliente.intermedio)}** | **${Math.round(totalCostosCliente.complejo)}** |\n`;
            
            // Continuar con el resto del markdown...
            return markdown;
        }
        
        function generarExcel(datos, config) {
            const wb = XLSX.utils.book_new();
            
            // Funci√≥n para categorizar building blocks
            function categorizarComponentes(componentes) {
                const categorias = {
                    arquitectura: [],
                    funcionales: [],
                    noFuncionales: []
                };
                
                componentes.forEach(comp => {
                    // Mapeo basado en categor√≠as existentes
                    if (comp.categoria === 'frontend' || comp.categoria === 'backend' || comp.categoria === 'devops') {
                        categorias.arquitectura.push(comp);
                    } else if (comp.categoria === 'ui' || comp.categoria === 'features' || comp.buildingBlocks.includes('user') || comp.buildingBlocks.includes('interface')) {
                        categorias.funcionales.push(comp);
                    } else {
                        categorias.noFuncionales.push(comp);
                    }
                });
                
                return categorias;
            }
            
            const categoriasData = categorizarComponentes(datos.componentes);
            const cotizacionData = [];
            
            // Header del documento con formato exacto del template
            cotizacionData.push(['WAZA', '', '', '', '', '', '', '', '', '', '', '', '', 'COTIZACI√ìN', 'MEXICO']);
            cotizacionData.push(['', '', '', '', '', '', '', '', '', '', '', '', '', '3 DE SEPTIEMBRE 2025']);
            cotizacionData.push(['CLIENTE:', '', '', '', '', '', '', '', '', '', 'MXN']);
            cotizacionData.push(['PROYECTO:', config.nombreProyecto || 'PLATAFORMA DE STREAMING']);
            cotizacionData.push(['EJECUTIVO:', '', '', '', '', '', '', '', '', '', 'JOS√â ANTONIO MANGARA']);
            cotizacionData.push(['']); // L√≠nea vac√≠a
            
            // Funci√≥n para agregar una secci√≥n
            function agregarSeccion(nombre, componentes, color) {
                // Header de la secci√≥n con formato exacto
                cotizacionData.push([nombre, '', '', '', '', '', '', '', '', '', '', '', '', '', 'PRECIO']);
                cotizacionData.push(['ITEM', 'DESCRIPCI√ìN', 'CANTIDAD', 'COSTO', 'TOKENS', 'HRS', 'COSTO FINAL', 'CANTIDAD', 'COSTO', 'HRS', 'SOFTWARES', 'COSTO FINAL', 'MARKUP', 'SUBTOTAL']);
                
                let subtotal = 0;
                componentes.forEach((comp, index) => {
                    const costoFinal = Math.round(comp.costoClienteIntermedio);
                    subtotal += costoFinal;
                    
                    cotizacionData.push([
                        comp.componente,
                        comp.buildingBlocks,
                        1, // Cantidad
                        Math.round(comp.costoClienteIntermedio * 0.6), // Costo base
                        Math.round(comp.horasIAIntermedio * 100), // Tokens simulados
                        comp.horasIAIntermedio,
                        Math.round(comp.costoClienteIntermedio * 0.6),
                        1, // Cantidad humanos
                        Math.round(comp.costoClienteIntermedio * 0.4), // Costo humanos
                        Math.round(comp.horasIAIntermedio * 2), // Horas humanas (doble que IA)
                        'Herramientas Dev',
                        Math.round(comp.costoClienteIntermedio * 0.4),
                        config.markupCliente + '%',
                        costoFinal
                    ]);
                });
                
                // Subtotal de la secci√≥n
                cotizacionData.push(['SUBTOTAL', '', '', '', '', '', '', '', '', '', '', '', '', subtotal]);
                cotizacionData.push(['']); // L√≠nea vac√≠a
                
                return subtotal;
            }
            
            // Agregar las tres secciones
            let totalGeneral = 0;
            totalGeneral += agregarSeccion('Arquitectura T√©cnica', categoriasData.arquitectura, 'blue');
            totalGeneral += agregarSeccion('Requisitos Funcionales', categoriasData.funcionales, 'blue');
            totalGeneral += agregarSeccion('Requisitos No Funcionales', categoriasData.noFuncionales, 'blue');
            
            // Total general
            cotizacionData.push(['GRAN TOTAL', '', '', '', '', '', '', '', '', '', '', '', '', totalGeneral]);
            cotizacionData.push(['']); // L√≠nea vac√≠a
            cotizacionData.push(['NOTAS:']);
            cotizacionData.push(['']);
            cotizacionData.push(['Alcance & cambios: Es una estimaci√≥n, si cambian requerimientos/t√©cnicas, cambian costo y tiempo; se tomar√°n los datos vigentes']);
            cotizacionData.push(['Moneda $ MXN. Impuestos no incluidos (IVA, s√≠ hay cargos del IVA), si hay cargo en USD (nacional), se podr√°n al tipo de cambio vigente.']);
            cotizacionData.push(['']);
            cotizacionData.push(['Responsabilidades del cliente: Entregar informaci√≥n, accesos, aprobaciones, API keys, dominio/DNS y permisos a tiempo.']);
            cotizacionData.push(['Roles & migracion: Incluye migracion basica desde DirectAdmin /Plesk/WhmlX+cintentrix especiales de codigos vivos']);
            cotizacionData.push(['cargos no incluyen instalaciones, ajustes de forma, propuestas de cambio y entitar otros']);
            cotizacionData.push(['Sugeridos: cron entregar plan estrategico, legalVox de informacion externa de datos, propuestas de segway y verificar tiempos']);
            
            const wsCotizacion = XLSX.utils.aoa_to_sheet(cotizacionData);
            XLSX.utils.book_append_sheet(wb, wsCotizacion, "Cotizaci√≥n_WAZA");
            
            // Tab 2: Estructura detallada original
            const detalladaData = [
                ['ID', 'Categor√≠a', 'Componente', 'Building Blocks', 
                 'Horas_IA_B√°sico', 'Horas_IA_Est√°ndar', 'Horas_IA_Enterprise', 
                 'Costo_Cliente_B√°sico', 'Costo_Cliente_Est√°ndar', 'Costo_Cliente_Enterprise']
            ];
            
            datos.componentes.forEach(comp => {
                detalladaData.push([
                    comp.id,
                    comp.categoria,
                    comp.componente,
                    comp.buildingBlocks,
                    comp.horasIAFacil,
                    comp.horasIAIntermedio,
                    comp.horasIAComplejo,
                    Math.round(comp.costoClienteFacil),
                    Math.round(comp.costoClienteIntermedio),
                    Math.round(comp.costoClienteComplejo)
                ]);
            });
            
            const wsDetallada = XLSX.utils.aoa_to_sheet(detalladaData);
            XLSX.utils.book_append_sheet(wb, wsDetallada, "Cotizaci√≥n_Detallada");
            
            // Descargar Excel
            const fecha = new Date().toISOString().slice(0, 10);
            XLSX.writeFile(wb, `cotizacion_${config.nombreProyecto.replace(/\s+/g, '_')}_${fecha}.xlsx`);
        }
        
        function generarMarkdown(datos, config) {
            const markdown = crearContenidoMarkdown(datos, config);
            
            // Crear y descargar archivo MD
            const blob = new Blob([markdown], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const fecha = new Date().toISOString().slice(0, 10);
            a.download = `cotizacion_${config.nombreProyecto.replace(/\s+/g, '_')}_${fecha}.md`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function llenarTemplate(datos, config) {
            // Template filling logic would go here
            mostrarMensaje('Funcionalidad de template pendiente de implementaci√≥n', 'error');
        }
        
        function previsualizarMD() {
            if (!buildingBlocksData) {
                mostrarMensaje('Primero carga el archivo JSON', 'error');
                return;
            }
            
            try {
                const config = obtenerConfiguracion();
                const datosEstructurados = procesarBuildingBlocks(buildingBlocksData, config);
                const markdown = crearContenidoMarkdown(datosEstructurados, config);
                
                document.getElementById('preview-content-013').textContent = markdown;
                document.getElementById('preview-container-012').style.display = 'block';
                
                mostrarMensaje('Preview generado', 'success');
            } catch (error) {
                mostrarMensaje('Error al generar preview: ' + error.message, 'error');
            }
        }
        
        // n8n Integration Function
        async function generarArchivosConN8N() {
            if (!buildingBlocksData) {
                mostrarMensaje('Primero carga el archivo JSON', 'error');
                return;
            }
            
            try {
                mostrarMensaje('Enviando datos para procesamiento con AI...', 'info');
                
                const config = obtenerConfiguracion();
                const payload = {
                    building_blocks: buildingBlocksData,
                    config: config
                };
                
                // Budget processor API URL
                const budgetApiUrl = 'http://localhost:3001/budget-quote';
                
                const response = await fetch(budgetApiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    mostrarMensaje('‚úÖ Cotizaci√≥n generada exitosamente con AI!', 'success');
                    
                    // Display the results
                    displayN8NResults(result.data);
                    
                    // Download files if available
                    if (result.data.markdown) {
                        downloadFile(result.data.markdown, result.data.filename + '.md', 'text/markdown');
                    }
                    if (result.data.csv) {
                        downloadFile(result.data.csv, result.data.filename + '.csv', 'text/csv');
                    }
                } else {
                    throw new Error(result.message || 'Error procesando datos');
                }
                
            } catch (error) {
                console.error('Error procesando:', error);
                mostrarMensaje('Error procesando: ' + error.message, 'error');
            }
        }
        
        function displayN8NResults(data) {
            // Create results display area
            let resultsDiv = document.getElementById('n8n-results-014');
            if (!resultsDiv) {
                resultsDiv = document.createElement('div');
                resultsDiv.id = 'n8n-results-014';
                resultsDiv.className = 'preview';
                resultsDiv.style.display = 'block';
                document.querySelector('.container').appendChild(resultsDiv);
            }
            
            const processed = data.processed;
            let html = `
                <h3>ü§ñ Resultados Procesados con AI</h3>
                <h4>Proyecto: ${processed.project_name}</h4>
                <p><strong>Generado:</strong> ${new Date(processed.generated_at).toLocaleString()}</p>
                
                <h4>üí∞ Costos Totales</h4>
                <table style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                    <tr style="background: #f0f0f0;">
                        <th style="border: 1px solid #ddd; padding: 8px;">Nivel</th>
                        <th style="border: 1px solid #ddd; padding: 8px;">Costo Total</th>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">B√°sico</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">$${Math.round(processed.totals.basic).toLocaleString()} MXN</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">Est√°ndar</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">$${Math.round(processed.totals.standard).toLocaleString()} MXN</td>
                    </tr>
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px;">Enterprise</td>
                        <td style="border: 1px solid #ddd; padding: 8px;">$${Math.round(processed.totals.enterprise).toLocaleString()} MXN</td>
                    </tr>
                </table>
                
                <h4>üìã Categor√≠as</h4>
            `;
            
            for (const [name, category] of Object.entries(processed.categories)) {
                html += `
                    <div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                        <h5>${name}</h5>
                        <p><strong>Items:</strong> ${category.items}</p>
                        <p><strong>Horas:</strong> ${category.hours.basic.toFixed(1)} / ${category.hours.standard.toFixed(1)} / ${category.hours.enterprise.toFixed(1)}</p>
                        <p><strong>Costos:</strong> $${Math.round(category.costs.basic).toLocaleString()} / $${Math.round(category.costs.standard).toLocaleString()} / $${Math.round(category.costs.enterprise).toLocaleString()} MXN</p>
                    </div>
                `;
            }
            
            html += `
                <h4>‚öôÔ∏è Configuraci√≥n Aplicada</h4>
                <ul>
                    <li><strong>Eficiencia IA:</strong> ${processed.config.eficienciaIA || 35}%</li>
                    <li><strong>Markup:</strong> ${processed.config.markup || 40}%</li>
                    <li><strong>Tarifa IA:</strong> $${processed.config.tarifaIA || 300} MXN/hora</li>
                    <li><strong>Factor PM:</strong> ${processed.config.factorPM || 18}%</li>
                    <li><strong>Factor Testing:</strong> ${processed.config.factorTesting || 12}%</li>
                    <li><strong>Factor Contingencia:</strong> ${processed.config.factorContingencia || 20}%</li>
                </ul>
            `;
            
            resultsDiv.innerHTML = html;
        }
        
        // Google Sheets API configuration

        let isGoogleAPIReady = false;

        // Inicializar Google API
        function initializeGoogleAPI() {
            return new Promise((resolve, reject) => {
                gapi.load('client:auth2', async () => {
                    try {
                        await gapi.client.init({
                            apiKey: GOOGLE_CONFIG.apiKey,
                            clientId: GOOGLE_CONFIG.clientId,
                            discoveryDocs: GOOGLE_CONFIG.discoveryDocs,
                            scope: GOOGLE_CONFIG.scopes
                        });
                        isGoogleAPIReady = true;
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                });
            });
        }

        // Funci√≥n autom√°tica completa con autenticaci√≥n Google API
        async function generarGoogleSheets() {
            if (!buildingBlocksData) {
                mostrarMensaje('Primero carga el archivo JSON', 'error');
                return;
            }

            try {
                mostrarMensaje('üîÑ Inicializando Google API...', 'info');
                console.log('üîÑ Iniciando proceso autom√°tico completo...');

                const config = obtenerConfiguracion();
                const datos = procesarBuildingBlocks(buildingBlocksData, config);

                console.log('üìä Datos procesados:', datos.componentes.length, 'componentes');

                // Autenticar con Google
                console.log('üîê Iniciando autenticaci√≥n...');
                await authenticateGoogle();
                console.log('‚úÖ Autenticaci√≥n completada');

                mostrarMensaje('üîÑ Creando copia del template...', 'info');

                // Crear copia del template autom√°ticamente usando el m√©todo que funciona
                const templateId = '1wR49oqHn3NdKj9pFzMdM2fpFpcYx7CxIZhLUHolWcA4';
                const fecha = new Date().toISOString().slice(0, 10);
                const nombreArchivo = `Cotizaci√≥n_${config.nombreProyecto.replace(/\s+/g, '_')}_${fecha}`;

                const newSheetId = await createSheetFromTemplate(templateId, nombreArchivo);

                mostrarMensaje('üîÑ Llenando datos autom√°ticamente en 3 tiers...', 'info');

                // Llenar datos en los 3 tabs con diferentes multiplicadores
                const tiers = [
                    { name: 'B√°sico (25%)', multiplier: 0.25, sheetId: 0 },
                    { name: 'Est√°ndar (100%)', multiplier: 1.0, sheetId: 1 },
                    { name: 'Premium (175%)', multiplier: 1.75, sheetId: 2 }
                ];

                for (const tier of tiers) {
                    console.log(`üìä Llenando tab: ${tier.name} con multiplicador ${tier.multiplier}`);
                    const configTier = { ...config, tierMultiplier: tier.multiplier, tierName: tier.name };
                    await populateGoogleSheetWithTier(newSheetId, datos, configTier, tier.name);
                }

                // Abrir el sheet completado
                const newSheetUrl = `https://docs.google.com/spreadsheets/d/${newSheetId}`;
                window.open(newSheetUrl, '_blank');

                mostrarMensaje('‚úÖ Google Sheet creado y llenado autom√°ticamente!', 'success');

            } catch (error) {
                console.error('Error:', error);
                const errorMessage = error.message || error.toString() || 'Error desconocido';
                if (errorMessage.includes('popup_blocked')) {
                    mostrarMensaje('‚ùå Popup bloqueado. Permite popups para este sitio.', 'error');
                } else {
                    mostrarMensaje('‚ùå Error: ' + errorMessage, 'error');
                }
            }
        }

        // Autenticar con Google
        // Inicializaci√≥n GIS cuando la p√°gina carga
        function initializeGIS() {
            return new Promise((resolve, reject) => {
                console.log('üîÑ Inicializando Google Identity Services...');

                try {
                    // Inicializar token client para OAuth 2.0
                    tokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: CLIENT_ID,
                        scope: SCOPES,
                        callback: (tokenResponse) => {
                            console.log('‚úÖ Token recibido:', tokenResponse);
                            accessToken = tokenResponse.access_token;
                        },
                        error_callback: (error) => {
                            console.error('‚ùå Error en OAuth:', error);
                        }
                    });

                    console.log('‚úÖ Token client inicializado correctamente');

                    // Inicializar gapi client
                    gapi.load('client', async () => {
                        try {
                            await gapi.client.init({
                                apiKey: API_KEY,
                                discoveryDocs: [
                                    'https://sheets.googleapis.com/$discovery/rest?version=v4',
                                    'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
                                ]
                            });
                            console.log('‚úÖ GAPI Client inicializado');
                            isGoogleApiLoaded = true;
                            resolve(); // Resolver aqu√≠ cuando todo est√© listo
                        } catch (error) {
                            console.error('‚ùå Error inicializando GAPI Client:', error);
                            reject(error);
                        }
                    });

                } catch (error) {
                    console.error('‚ùå Error inicializando tokenClient:', error);
                    reject(error);
                }
            });
        }

        async function authenticateGoogle() {
            return new Promise((resolve, reject) => {
                console.log('üîê Iniciando autenticaci√≥n OAuth...');

                if (!tokenClient) {
                    reject(new Error('Token client no inicializado'));
                    return;
                }

                // Configurar callback del token
                tokenClient.callback = (resp) => {
                    if (resp.error !== undefined) {
                        console.error('‚ùå Error en OAuth:', resp);
                        reject(resp);
                        return;
                    }
                    console.log('‚úÖ Autenticaci√≥n exitosa');
                    accessToken = resp.access_token;

                    // Configurar el token en gapi client
                    gapi.client.setToken({
                        access_token: accessToken
                    });

                    resolve();
                };

                // Solicitar token
                tokenClient.requestAccessToken({prompt: 'consent'});
            });
        }

        // Crear sheet desde template (m√©todo que funciona)
        async function createSheetFromTemplate(templateId, newName) {
            try {
                console.log('üìã Creando sheet desde template:', templateId, 'con nombre:', newName);

                // 1. Leer datos del template CON F√ìRMULAS
                const templateData = await gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: templateId,
                    range: 'A1:Z100',
                    valueRenderOption: 'FORMULA'
                });

                console.log(`üìÑ Datos obtenidos del template: ${templateData.result.values ? templateData.result.values.length : 0} filas`);

                // 2. Crear nuevo spreadsheet con 3 tabs (tiers)
                const createResponse = await gapi.client.sheets.spreadsheets.create({
                    resource: {
                        properties: {
                            title: newName
                        },
                        sheets: [
                            {
                                properties: {
                                    title: 'B√°sico (25%)',
                                    sheetId: 0,
                                    gridProperties: {
                                        rowCount: 1000,
                                        columnCount: 26
                                    }
                                }
                            },
                            {
                                properties: {
                                    title: 'Est√°ndar (100%)',
                                    sheetId: 1,
                                    gridProperties: {
                                        rowCount: 1000,
                                        columnCount: 26
                                    }
                                }
                            },
                            {
                                properties: {
                                    title: 'Premium (175%)',
                                    sheetId: 2,
                                    gridProperties: {
                                        rowCount: 1000,
                                        columnCount: 26
                                    }
                                }
                            }
                        ]
                    }
                });

                const newSheetId = createResponse.result.spreadsheetId;
                console.log(`‚úÖ Nuevo spreadsheet creado con 3 tabs: ${newSheetId}`);

                // 3. Copiar template data a cada tab
                if (templateData.result.values && templateData.result.values.length > 0) {
                    const tiers = ['B√°sico (25%)', 'Est√°ndar (100%)', 'Premium (175%)'];

                    for (let i = 0; i < tiers.length; i++) {
                        await gapi.client.sheets.spreadsheets.values.update({
                            spreadsheetId: newSheetId,
                            range: `'${tiers[i]}'!A1`,
                            valueInputOption: 'USER_ENTERED',
                            resource: {
                                values: templateData.result.values
                            }
                        });
                        console.log(`‚úÖ Template copiado a tab: ${tiers[i]}`);
                    }
                }

                return newSheetId;

            } catch (error) {
                console.error('‚ùå Error creando sheet desde template:', error);
                throw error;
            }
        }

        // Insertar filas din√°micamente en Google Sheets
        async function insertRowsInSheet(sheetId, startRowIndex, numRows) {
            console.log(`‚ûï Insertando ${numRows} filas en posici√≥n ${startRowIndex}`);

            try {
                // Convertir de √≠ndice de fila (1-based) a √≠ndice API (0-based)
                const apiStartIndex = startRowIndex - 1;

                await gapi.client.sheets.spreadsheets.batchUpdate({
                    spreadsheetId: sheetId,
                    resource: {
                        requests: [{
                            insertDimension: {
                                range: {
                                    sheetId: 0,
                                    dimension: 'ROWS',
                                    startIndex: apiStartIndex,
                                    endIndex: apiStartIndex + numRows
                                },
                                inheritFromBefore: true
                            }
                        }]
                    }
                });
                console.log(`‚úÖ ${numRows} filas insertadas exitosamente en posici√≥n ${startRowIndex}`);
            } catch (error) {
                console.error('‚ùå Error insertando filas:', error);
                throw error;
            }
        }

        // Categorizar building blocks por secci√≥n seg√∫n categor√≠as Waza
        function categorizeComponents(componentes) {
            const arquitectura = componentes.filter(c =>
                c.categoria && (c.categoria === 'frontend' || c.categoria === 'infrastructure' || c.categoria === 'devops')
            );

            const funcionales = componentes.filter(c =>
                c.categoria && (c.categoria === 'backend' || c.categoria === 'integration' || c.categoria === 'database')
            );

            const noFuncionales = componentes.filter(c =>
                c.categoria && (c.categoria === 'security' || c.categoria === 'testing' || c.categoria === 'business')
            );

            return { arquitectura, funcionales, noFuncionales };
        }

        // Llenar datos en un tab espec√≠fico con tier personalizado
        async function populateGoogleSheetWithTier(sheetId, datos, config, tabName) {
            console.log(`üìã Llenando datos en tab "${tabName}" con multiplicador ${config.tierMultiplier}...`);

            try {
                // 1. Actualizar nombre del proyecto
                await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId: sheetId,
                    range: `'${tabName}'!B4:B4`,
                    valueInputOption: 'RAW',
                    resource: {
                        values: [[config.nombreProyecto]]
                    }
                });

                // 2. Categorizar componentes por secci√≥n
                const { arquitectura, funcionales, noFuncionales } = categorizeComponents(datos.componentes);

                console.log(`üìä ${tabName} - Arquitectura: ${arquitectura.length}, Funcionales: ${funcionales.length}, No Funcionales: ${noFuncionales.length}`);
                console.log('üîç Componentes No Funcionales:', noFuncionales.map(c => c.nombre));

                // 3. Calcular filas necesarias y posiciones (basadas en la estructura real del template)
                const minFilasPorSeccion = 3;

                // Posiciones iniciales en el template (verificadas en el sheet)
                let posArquitectura = 8;   // Datos empiezan en fila 8 (despu√©s del header en fila 6-7)
                let posFuncionales = 15;   // Datos empiezan en fila 15 (despu√©s del header en fila 13-14)
                let posNoFuncionales = 22; // Datos empiezan en fila 22 (despu√©s del header en fila 20-21)

                // 4. Primero llenar datos sin insertar filas (para evitar errores 400)
                console.log('üîß Llenando datos en posiciones existentes primero...');

                // Contador global para numeraci√≥n continua 1-12
                let contadorGlobal = 1;

                contadorGlobal = await fillSectionDataWithTier(sheetId, 'Arquitectura T√©cnica', arquitectura, posArquitectura, config, contadorGlobal, tabName);
                contadorGlobal = await fillSectionDataWithTier(sheetId, 'Requisitos Funcionales', funcionales, posFuncionales, config, contadorGlobal, tabName);
                contadorGlobal = await fillSectionDataWithTier(sheetId, 'Requisitos No Funcionales', noFuncionales, posNoFuncionales, config, contadorGlobal, tabName);

                console.log(`‚úÖ Datos llenados correctamente en tab "${tabName}"`);

            } catch (error) {
                console.error(`‚ùå Error llenando datos en tab "${tabName}":`, error);
                throw error;
            }
        }

        // Llenar datos en Google Sheet (m√©todo inteligente y din√°mico) - ORIGINAL
        async function populateGoogleSheetSimple(sheetId, datos, config) {
            console.log('üìã Llenando datos con expansi√≥n din√°mica...');

            try {
                // 1. Actualizar nombre del proyecto
                await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId: sheetId,
                    range: 'B4:B4',
                    valueInputOption: 'RAW',
                    resource: {
                        values: [[config.nombreProyecto]]
                    }
                });

                // 2. Categorizar componentes por secci√≥n
                const { arquitectura, funcionales, noFuncionales } = categorizeComponents(datos.componentes);

                console.log(`üìä Arquitectura: ${arquitectura.length}, Funcionales: ${funcionales.length}, No Funcionales: ${noFuncionales.length}`);

                // 3. Calcular filas necesarias y posiciones (basadas en la estructura real del template)
                const minFilasPorSeccion = 3;

                // Posiciones iniciales en el template (verificadas en el sheet)
                let posArquitectura = 8;   // Datos empiezan en fila 8 (despu√©s del header en fila 6-7)
                let posFuncionales = 15;   // Datos empiezan en fila 15 (despu√©s del header en fila 13-14)
                let posNoFuncionales = 22; // Datos empiezan en fila 22 (despu√©s del header en fila 20-21)

                // 4. Primero llenar datos sin insertar filas (para evitar errores 400)
                console.log('üîß Llenando datos en posiciones existentes primero...');

                // Contador global para numeraci√≥n continua 1-12
                let contadorGlobal = 1;

                contadorGlobal = await fillSectionData(sheetId, 'Arquitectura T√©cnica', arquitectura, posArquitectura, config, contadorGlobal);
                contadorGlobal = await fillSectionData(sheetId, 'Requisitos Funcionales', funcionales, posFuncionales, config, contadorGlobal);
                contadorGlobal = await fillSectionData(sheetId, 'Requisitos No Funcionales', noFuncionales, posNoFuncionales, config, contadorGlobal);

                console.log('‚úÖ Datos llenados correctamente con expansi√≥n din√°mica');

            } catch (error) {
                console.error('‚ùå Error llenando datos:', error);
                throw error;
            }
        }

        // Llenar datos de una secci√≥n espec√≠fica con tier personalizado
        async function fillSectionDataWithTier(sheetId, sectionName, componentes, startRow, config, contadorInicial = 1, tabName) {
            if (componentes.length === 0) {
                console.log(`‚ö†Ô∏è Sin componentes para ${sectionName} en ${tabName}`);
                return contadorInicial; // Devolver el contador sin cambios
            }

            console.log(`üìù Llenando ${sectionName} en ${tabName}: ${componentes.length} componentes desde fila ${startRow}, numeraci√≥n desde ${contadorInicial}`);

            const rows = componentes.map((comp, index) => {
                const costoBase = comp.costoCliente || 0;
                const horasTotal = comp.horas || 0;
                const horasIA = comp.horasIA || (horasTotal * 0.7);
                const horasHumanas = comp.horasHumanas || (horasTotal * 0.3);
                const markup = config.markup || 40;
                const tierMultiplier = config.tierMultiplier || 1.0; // Multiplicador de tier

                // Aplicar multiplicador de tier a todos los costos
                const costoConTier = Math.round(costoBase * tierMultiplier);

                return [
                    contadorInicial + index, // Numeraci√≥n continua en columna A
                    comp.nombre || 'Sin nombre',
                    comp.descripcion || `Componente de ${sectionName}`,
                    1,
                    Math.round(costoConTier / 500) || 0,
                    Math.round(horasIA) || 0,
                    Math.round(horasIA) || 0,
                    Math.round(costoConTier / 500) || 0,
                    1,
                    Math.round(costoConTier * 0.3 / 500) || 0,
                    Math.round(horasHumanas) || 0,
                    'Dev Tools',
                    Math.round(costoConTier / 500) || 0,
                    `${markup}%`,
                    Math.round(costoConTier * (1 + markup/100) / 500) || 0
                ];
            });

            const endRow = startRow + componentes.length - 1;
            const range = `'${tabName}'!A${startRow}:O${endRow}`;  // Incluir nombre del tab

            try {
                await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId: sheetId,
                    range: range,
                    valueInputOption: 'RAW',
                    resource: {
                        values: rows
                    }
                });

                console.log(`‚úÖ ${sectionName} llenada en ${tabName}: ${componentes.length} componentes en ${range}`);

                // Devolver el pr√≥ximo n√∫mero a usar
                return contadorInicial + componentes.length;
            } catch (error) {
                console.error(`‚ùå Error llenando ${sectionName} en ${tabName}:`, error);
                throw error;
            }
        }

        // Llenar datos de una secci√≥n espec√≠fica - ORIGINAL
        async function fillSectionData(sheetId, sectionName, componentes, startRow, config, contadorInicial = 1) {
            if (componentes.length === 0) {
                console.log(`‚ö†Ô∏è Sin componentes para ${sectionName}`);
                return contadorInicial; // Devolver el contador sin cambios
            }

            console.log(`üìù Llenando ${sectionName}: ${componentes.length} componentes desde fila ${startRow}, numeraci√≥n desde ${contadorInicial}`);

            const rows = componentes.map((comp, index) => {
                const costoBase = comp.costoCliente || 0;
                const horasTotal = comp.horas || 0;
                const horasIA = comp.horasIA || (horasTotal * 0.7);
                const horasHumanas = comp.horasHumanas || (horasTotal * 0.3);
                const markup = config.markup || 40;

                return [
                    contadorInicial + index, // Numeraci√≥n continua en columna A
                    comp.nombre || 'Sin nombre',
                    comp.descripcion || `Componente de ${sectionName}`,
                    1,
                    Math.round(costoBase / 500) || 0,
                    Math.round(horasIA) || 0,
                    Math.round(horasIA) || 0,
                    Math.round(costoBase / 500) || 0,
                    1,
                    Math.round(costoBase * 0.3 / 500) || 0,
                    Math.round(horasHumanas) || 0,
                    'Dev Tools',
                    Math.round(costoBase / 500) || 0,
                    `${markup}%`,
                    Math.round(costoBase * (1 + markup/100) / 500) || 0
                ];
            });

            const endRow = startRow + componentes.length - 1;
            const range = `A${startRow}:O${endRow}`;  // Expandido a columna O para incluir la numeraci√≥n

            try {
                await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId: sheetId,
                    range: range,
                    valueInputOption: 'RAW',
                    resource: {
                        values: rows
                    }
                });

                console.log(`‚úÖ ${sectionName} llenada: ${componentes.length} componentes en ${range}`);

                // Devolver el pr√≥ximo n√∫mero a usar
                return contadorInicial + componentes.length;
            } catch (error) {
                console.error(`‚ùå Error llenando ${sectionName}:`, error);
                throw error;
            }
        }

        // Llenar datos en Google Sheet inteligentemente (insertar/eliminar filas) - BACKUP
        async function populateGoogleSheetSmart(sheetId, datos, config) {
            console.log('üìã Iniciando llenado inteligente...');

            // Categorizar componentes como pediste
            const arquitectura = datos.componentes.filter(c =>
                c.categoria && (c.categoria === 'frontend' || c.categoria === 'backend' || c.categoria === 'devops')
            );
            const funcionales = datos.componentes.filter(c =>
                c.categoria && !['frontend', 'backend', 'devops'].includes(c.categoria)
            );
            const noFuncionales = datos.componentes.filter(c =>
                c.categoria && (c.categoria === 'security' || c.categoria === 'performance' || c.categoria === 'monitoring')
            );

            console.log(`üìä Arquitectura: ${arquitectura.length}, Funcionales: ${funcionales.length}, No Funcionales: ${noFuncionales.length}`);

            // 1. Actualizar datos del proyecto
            await gapi.client.sheets.spreadsheets.values.update({
                spreadsheetId: sheetId,
                range: 'B4:B4',
                valueInputOption: 'RAW',
                resource: {
                    values: [[config.nombreProyecto]]
                }
            });

            // 2. Llenar Arquitectura T√©cnica (empezar en fila 7)
            await fillSection(sheetId, arquitectura, 7, 'Arquitectura T√©cnica', config);

            // 3. Llenar Requisitos Funcionales (empezar despu√©s de arquitectura)
            const funcionalStartRow = 7 + Math.max(arquitectura.length, 3) + 4; // +4 para subtotal y espacios
            await fillSection(sheetId, funcionales, funcionalStartRow, 'Requisitos Funcionales', config);

            // 4. Llenar Requisitos No Funcionales (si existen)
            if (noFuncionales.length > 0) {
                const noFuncionalStartRow = funcionalStartRow + Math.max(funcionales.length, 3) + 4;
                await fillSection(sheetId, noFuncionales, noFuncionalStartRow, 'Requisitos No Funcionales', config);
            }

            console.log('‚úÖ Llenado inteligente completado');
        }

        // Funci√≥n auxiliar para llenar una secci√≥n con inserci√≥n/eliminaci√≥n autom√°tica
        async function fillSection(sheetId, items, startRow, sectionName, config) {
            console.log(`üîÑ Llenando secci√≥n: ${sectionName} - ${items.length} items desde fila ${startRow}`);

            const minRows = 3; // M√≠nimo 3 filas por secci√≥n
            const maxRows = 10; // M√°ximo 10 filas por secci√≥n
            const neededRows = Math.max(items.length, minRows);
            const actualRows = Math.min(neededRows, maxRows);

            // Si necesitamos m√°s filas, insertar
            if (items.length > minRows) {
                const rowsToInsert = Math.min(items.length - minRows, maxRows - minRows);
                if (rowsToInsert > 0) {
                    console.log(`‚ûï Insertando ${rowsToInsert} filas en fila ${startRow + minRows}`);
                    await gapi.client.sheets.spreadsheets.batchUpdate({
                        spreadsheetId: sheetId,
                        resource: {
                            requests: [{
                                insertDimension: {
                                    range: {
                                        sheetId: 0,
                                        dimension: 'ROWS',
                                        startIndex: startRow + minRows - 1,
                                        endIndex: startRow + minRows - 1 + rowsToInsert
                                    },
                                    inheritFromBefore: true
                                }
                            }]
                        }
                    });
                }
            }

            // Llenar datos en las filas
            const dataRows = [];
            for (let i = 0; i < actualRows && i < items.length; i++) {
                const item = items[i];
                dataRows.push([
                    item.componente,                                    // ITEM
                    item.buildingBlocks,                               // DESCRIPCION
                    1,                                                 // CANTIDAD
                    Math.round(item.costoClienteIntermedio * 0.6),     // COSTO
                    Math.round(item.horasIAIntermedio * 100),          // TOKENS
                    item.horasIAIntermedio,                            // HRS
                    Math.round(item.costoClienteIntermedio * 0.6),     // COSTO FINAL
                    1,                                                 // CANTIDAD (humanos)
                    Math.round(item.costoClienteIntermedio * 0.4),     // COSTO (humanos)
                    Math.round(item.horasIAIntermedio * 2),            // HRS (humanos)
                    'Herramientas Dev',                                // SOFTWARES
                    Math.round(item.costoClienteIntermedio * 0.4),     // COSTO FINAL (humanos)
                    `${config.markup}%`,                               // MARKUP
                    Math.round(item.costoClienteIntermedio)            // SUBTOTAL
                ]);
            }

            if (dataRows.length > 0) {
                const range = `A${startRow}:N${startRow + dataRows.length - 1}`;
                console.log(`üìù Escribiendo datos en rango: ${range}`);

                await gapi.client.sheets.spreadsheets.values.update({
                    spreadsheetId: sheetId,
                    range: range,
                    valueInputOption: 'RAW',
                    resource: {
                        values: dataRows
                    }
                });
            }

            console.log(`‚úÖ Secci√≥n ${sectionName} completada`);
        }

        // Llenar datos en Google Sheet autom√°ticamente (funci√≥n original como backup)
        async function populateGoogleSheet(sheetId, datos, config) {
            const values = [];
            
            // Categorizar componentes
            const arquitectura = datos.componentes.filter(c => c.categoria && (c.categoria === 'frontend' || c.categoria === 'backend' || c.categoria === 'devops'));
            const funcionales = datos.componentes.filter(c => c.categoria && !['frontend', 'backend', 'devops'].includes(c.categoria));
            
            // Llenar secci√≥n Arquitectura T√©cnica (empezar en fila 8)
            let currentRow = 8;
            arquitectura.forEach(comp => {
                values.push({
                    range: `A${currentRow}:N${currentRow}`,
                    values: [[
                        comp.componente,
                        comp.buildingBlocks,
                        1,
                        Math.round(comp.costoClienteIntermedio * 0.6),
                        Math.round(comp.horasIAIntermedio * 100),
                        comp.horasIAIntermedio,
                        Math.round(comp.costoClienteIntermedio * 0.6),
                        1,
                        Math.round(comp.costoClienteIntermedio * 0.4),
                        Math.round(comp.horasIAIntermedio * 2),
                        'Herramientas Dev',
                        Math.round(comp.costoClienteIntermedio * 0.4),
                        config.markupCliente + '%',
                        Math.round(comp.costoClienteIntermedio)
                    ]]
                });
                currentRow++;
            });
            
            // Saltar a secci√≥n Requisitos Funcionales (aproximadamente fila 20)
            currentRow = 20;
            funcionales.forEach(comp => {
                values.push({
                    range: `A${currentRow}:N${currentRow}`,
                    values: [[
                        comp.componente,
                        comp.buildingBlocks,
                        1,
                        Math.round(comp.costoClienteIntermedio * 0.6),
                        Math.round(comp.horasIAIntermedio * 100),
                        comp.horasIAIntermedio,
                        Math.round(comp.costoClienteIntermedio * 0.6),
                        1,
                        Math.round(comp.costoClienteIntermedio * 0.4),
                        Math.round(comp.horasIAIntermedio * 2),
                        'Herramientas Dev',
                        Math.round(comp.costoClienteIntermedio * 0.4),
                        config.markupCliente + '%',
                        Math.round(comp.costoClienteIntermedio)
                    ]]
                });
                currentRow++;
            });

            // Actualizar datos del proyecto
            values.push({
                range: 'B4:B4',
                values: [[config.nombreProyecto]]
            });

            // Enviar todos los datos de una vez
            const batchUpdateRequest = {
                valueInputOption: 'RAW',
                data: values
            };

            await gapi.client.sheets.spreadsheets.values.batchUpdate({
                spreadsheetId: sheetId,
                resource: batchUpdateRequest
            });
        }

        // FUNCI√ìN ELIMINADA - Solo modo autom√°tico

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function mostrarMensaje(mensaje, tipo) {
            const div = document.createElement('div');
            div.className = tipo;
            div.textContent = mensaje;

            const container = document.querySelector('.container');
            container.appendChild(div);

            setTimeout(() => div.remove(), 5000);
        }

        // Esperar a que Google Identity Services est√© disponible
        function waitForGoogleGSI() {
            return new Promise((resolve) => {
                const checkGSI = () => {
                    if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) {
                        console.log('‚úÖ Google Identity Services disponible');
                        resolve();
                    } else {
                        console.log('‚è≥ Esperando Google Identity Services...');
                        setTimeout(checkGSI, 100);
                    }
                };
                checkGSI();
            });
        }

        // Inicializar cuando la p√°gina carga
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üöÄ P√°gina cargada, esperando Google GIS...');
            await waitForGoogleGSI();
            console.log('üîÑ Inicializando GIS...');
            initializeGIS();
        });
    </script>
</body>
</html>